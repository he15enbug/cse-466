# Memory Errors
- *babymem_level4.0*: There is a check on the payload size to ensure our input won't overflow the buffer. We can bypass it by given a payload size `-1`, the challenge uses a signed integer to hold this, which will treat this value as `-1`, so we can pass the check. But for the `read` function, it will treat `-1` as an unsigned integer `0xff...fff`, which is enough for us to reach the return address
    - `rbp = 0x7ffcb4903d50`
    - `&buffer = 0x7ffcb4903d00 (rbp-0x50)`
    - `&win = 0x4024bc`
- *babymem_level4.1*: use the same method as the previous challenge to bypass the payload size check. This time, no address information is provided, we need to `gdb` the challenge to figure out those information
    - `rbp = 0x7fffca526940`
    - `&buffer = 0x7fffca526900 (rbp-0x40)`
    - `&win = 0x401b01`
- *babymem_level5.0*: we are allowed to input multiple payload records, and they will be concatenated together. There is a size check to ensure the total size of the payload fits in the buffer. By debugging the challenge program, we can know that it only checks whether `record_size * record_num < 8`, if we input `-1` and `-1`, we can bypass this check. But another problem is that, the input is 32-bit, the `read()` will take a 64-bit value as its third parameter, `0xffffffff` in 64-bit registers will be a positive number, and the result is very large. When `rdx` is large, `read()` will not read anything, and return a negative result. I am not sure the reason for this yet, but we need to find another way. Take advantage of integer overflow. For example, `record_size = INT32_MIN`, `record_num = 2`, `record_size * record_num` will get `0`
    - `rbp = 0x00007ffc1284b0d0`
    - `&buffer = 0x7ffc1284b080 (rbp-0x50)`
    - `&win = 0x401b01`   
- *babymem_level5.1*: use the same method
    - `rbp = 0x00007ffcca645050`
    - `&buffer = 0x7ffcca644fd0 (rbp-0x50)`
    - `&win = 0x401453`

- *babymem_level9.0*: this time the stack canary is enabled. The core logic of the challenge is `while(n < size) n += read(0, input + n, 1);`, we can use this to overwrite local variable `n` to jump over the canary and overwrite the return address directly. The program is position indepentdent, that means each time we run it, the address of `win_authed` function varies. But due to memory alignment, the first 48 bits of `&win_authed` and the original return address are always the same, and the last 2 bytes of `&win_authed` are `0x?5f5`, so we only need to brute-force this `?` (there are 16 cases), specifically, we fix `?` to a number, and keep running the challenge again and again, until we hit the correct `win_authed` address
    - `&buffer = rbp - 0x70`
    - `&n = &buffer + 100`
    - `&ret_addr = &buffer + 120`
    - `&win_authed = (<OriginalReturnAddress> & 0xffffffff0000) + 0x?5f5`
    - We need to jump over the canary, and modify the 2 bytes from `&buffer + 120` to `0xf5` and `0x?5`, respectively
    - The initial value of `n` is zero, we need to overwrite the buffer, such that after one `n += read(0, input + 0, 1)` instruction, `n` becomes 120 (`0x78`). Then we can input the 2 bytes. `read(0, input + 0, 1)` allows us to input at most 1 byte. First, we need to write 100 bytes to reach the position of `n`, then we need to write a specific value `0x77` to the location, and `n = 0x77+0x01 = 0x78`, we can then write the 2 bytes `0xf5` and `0xa5`
    - An important thing is that there is a check on `edi` in `win_authed`, it only opens and prints out the flag when `edi` is `0x1337`, so we need to figure out how to set `edi` before the `challenge` returns. Unfortunately, we cannot modify `edi` to what we want. Fortunately, we can just jump to a position after that check in `win_authed`, e.g., jump to `win_authed+28` (`0x...?611`)
- *babymem_level9.1*: 
    - `win_authed+28` at `0x...?98c`
    - `&n - &buffer = 0x7ffd906b02bc - 0x7ffd906b02a0 = 28 = 0x1c`
    - `&ret_addr - &buffer = 0x7ffd906b02d0 - 0x7ffd906b02a0 + 8 = 0x38`
- *babymem_level11.0*: the flag will be loaded into memory, but at no point it will be printed out. The input buffer will be stored in an mapped page of memory
- *babymem_level11.1*